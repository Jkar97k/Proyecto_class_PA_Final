import network
import urequests
import ujson
import time # Usamos time, pero internamente es utime en MicroPython
import random

# --- CONFIGURACIÃ“N ---
WIFI_SSID = 'Wokwi-GUEST'
WIFI_PASS = ''
# URL del endpoint de tu proxy en Replit (ESTA DEBE SER LA URL DEL PROXY DE REPLIT)
# ASUME que la URL que usaste en tu proxy es correcta.
SERVER_URL = "https://8423ecfd-f092-4e20-8fab-219d18f035e6-00-25frin13h2g1f.spock.replit.dev/receive_sensor_data" 
NUM_SENSORES = 3

# --- VARIABLES DE SIMULACIÃ“N DE TIEMPO ---
# Definir una hora de inicio en el pasado (e.g., 2025-10-01 00:00:00 UTC)
# Epoch time para 2025-10-01 00:00:00 UTC es 1727788800 segundos.
INITIAL_EPOCH_SECONDS = 1727788800
# Almacenaremos el tiempo simulado en milisegundos (ms) para alta precisiÃ³n
current_sim_time_ms = INITIAL_EPOCH_SECONDS * 1000 
iteration_counter = 0


# --- CONECTAR WIFI ---
def connect_wifi():
    wlan = network.WLAN(network.STA_IF)
    wlan.active(True)
    if not wlan.isconnected():
        print('ðŸ”Œ Conectando a WiFi...')
        wlan.connect(WIFI_SSID, WIFI_PASS)
        timeout = 60
        while not wlan.isconnected() and timeout > 0:
            print('.', end='')
            time.sleep(1)
            timeout -= 1
        print()
    if wlan.isconnected():
        print('âœ… WiFi Conectado')
        print('ConfiguraciÃ³n de red:', wlan.ifconfig())
        return True
    else:
        print('âŒ No se pudo conectar a WiFi')
        return False


# --- ENVIAR DATOS ---
def send_sensor_data(sensor_id, current_timestamp_ms):
    """EnvÃ­a los datos simulados de un sensor con el timestamp simulado."""
    # 0 = Libre, 1 = Ocupado
    estado_ocupacion = random.choice([0, 1]) 
    
    # ðŸŽ¯ PAYLOAD ACTUALIZADO: Incluye 'simulated_timestamp_ms'
    payload = {
        "codigosensor": sensor_id,
        "estado": estado_ocupacion,
        "simulated_timestamp_ms": current_timestamp_ms # Nuevo campo
    }

    # --- CORRECCIÃ“N MICROPYTHON: Usar el timestamp numÃ©rico en lugar de strftime ---
    # La fecha legible ya no se genera aquÃ­, solo se imprime el valor en ms.
    
    print(f"\nðŸ“¤ Enviando Sensor {payload['codigosensor']} | Hora Sim (ms): {current_timestamp_ms} -> {'OCUPADO' if estado_ocupacion else 'LIBRE'}")
    # ---------------------------------------------------------------------------------

    try:
        headers = {'Content-Type': 'application/json'}
        # Se envÃ­a al proxy de Replit, que lo reenvÃ­a a Render.
        response = urequests.post(SERVER_URL, data=ujson.dumps(payload), headers=headers) 

        if response.status_code == 201:
            print(f"âœ… Sensor {sensor_id} guardado correctamente.")
        else:
            print(f"âš ï¸ Error {response.status_code}: {response.text}")

        response.close()

    except Exception as e:
        print(f"âŒ Error al enviar datos: {e}")


# --- LOOP PRINCIPAL ---
def main():
    global current_sim_time_ms
    global iteration_counter
    
    if connect_wifi():
        while True:
            print("-" * 30)

            # 1. INCREMENTO HORARIO RANDOM (Cada iteraciÃ³n del loop principal)
            # Agregar entre 1 y 4 horas al tiempo simulado (en ms)
            # 1 hora = 3600 segundos * 1000 ms/s
            hours_to_add = random.randint(1, 4) 
            current_sim_time_ms += hours_to_add * 3600 * 1000 
            
            print(f"âŒ› Incrementando hora simulada en {hours_to_add} horas.")
            
            # 2. INCREMENTO DIARIO (Cada dos iteraciones)
            iteration_counter += 1
            if iteration_counter % 2 == 0:
                # 1 dÃ­a = 24 horas * 3600 segundos/hora * 1000 ms/s
                current_sim_time_ms += 24 * 3600 * 1000 
                print("ðŸ“… Agregando un dÃ­a extra a la simulaciÃ³n.")
                
            # Enviar datos con el nuevo timestamp simulado
            for sensor_id in range(1, NUM_SENSORES + 1): 
                send_sensor_data(sensor_id, current_sim_time_ms)
                time.sleep(0.5) # Pausa mÃ­nima para que se vean los logs

            print("\nâ± Esperando 10 segundos antes del siguiente envÃ­o REAL...\n")
            time.sleep(5)


# --- EJECUTAR ---
if __name__ == '__main__':
    main()
    
# proxy https://replit.com/@jgarcia861/ProxySensorData



docker compose down -v --remove-orphans


...........................
import os
import json
import time
from pathlib import Path
from datetime import datetime# Se aÃ±adiÃ³ 'timezone' para usar en la ruta /query
from bson import ObjectId
from pymongo import MongoClient
from dotenv import load_dotenv

from flask import Flask, render_template, request, jsonify, Response

# --- Serializador JSON personalizado para manejar ObjectId y datetime ---
class JSONEncoder(json.JSONEncoder):
    def default(self, o):
        if isinstance(o, ObjectId):
            return str(o)
        if isinstance(o, datetime):
            # Convierte datetime a string legible
            return o.isoformat()
        return super().default(o)


# Carga el archivo .env
env_path = Path(__file__).resolve().parent.parent / ".env"
load_dotenv(dotenv_path=env_path)

app = Flask(__name__)
# Aplicar el encoder personalizado a la aplicaciÃ³n Flask
app.json_encoder = JSONEncoder


# --- Variables de Entorno ---
ATLAS_URI = os.getenv('MONGODB_ATLAS_URI')
LOCAL_URI = os.getenv('MONGODB_LOCAL_URI')

# --- Variables globales de ConexiÃ³n y Colecciones ---
client_atlas = None
client_local = None
db_atlas = None
db_local = None
sensor1_collection = None
sensor2_collection = None
sensor3_collection = None
COLECCIONES_MAP = {} # Mapa para Grafana


def init_mongodb_connection():
    """Inicializa la conexiÃ³n a MongoDB Atlas y Local."""
    global client_atlas, client_local, db_atlas, db_local
    global sensor1_collection, sensor2_collection, sensor3_collection
    global COLECCIONES_MAP

    ATLAS_CONNECTION_OPTS = {'serverSelectionTimeoutMS': 5000, 'uuidRepresentation': 'standard'}

    # --- ConexiÃ³n a Atlas ---
    if ATLAS_URI:
        try:
            client_atlas = MongoClient(ATLAS_URI, **ATLAS_CONNECTION_OPTS)
            client_atlas.admin.command('ping')
            db_atlas = client_atlas.get_database("DatosSensores")

            # Colecciones especÃ­ficas de Grafana/Sensores
            sensor1_collection = db_atlas["Sensor_1"]
            sensor2_collection = db_atlas["Sensor_2"]
            sensor3_collection = db_atlas["Sensor_3"]

            # Llenar el mapa para Grafana
            COLECCIONES_MAP = {
                "Sensor_1": sensor1_collection,
                "Sensor_2": sensor2_collection,
                "Sensor_3": sensor3_collection,
            }

            print(f"âœ… ConexiÃ³n ATLAS exitosa. Base de datos: {db_atlas.name}")
            print(f"Â  Â â”œâ”€ ColecciÃ³n 1: {sensor1_collection.name}")
            print(f"Â  Â â”œâ”€ ColecciÃ³n 2: {sensor2_collection.name}")
            print(f"Â  Â â””â”€ ColecciÃ³n 3: {sensor3_collection.name}")

        except Exception as e:
            print(f"âŒ Error de conexiÃ³n a MongoDB ATLAS: {e}")

    # --- ConexiÃ³n Local ---
    if LOCAL_URI:
        try:
            client_local = MongoClient(LOCAL_URI, serverSelectionTimeoutMS=5000)
            client_local.admin.command('ping')
            db_local = client_local.get_database("localDB")
            print(f"âœ… ConexiÃ³n LOCAL exitosa. Base de datos: {db_local.name}")
        except Exception as e:
            print(f"âŒ Error de conexiÃ³n a MongoDB LOCAL: {e}")


# Inicializar al cargar la app
init_mongodb_connection()


# --------------------------------------------------------
#               RUTAS DE PRUEBA Y DATOS RAW
# --------------------------------------------------------

@app.route('/vamos')
def vamos():
    """Ruta de prueba de operaciones en Atlas y Local."""
    message_atlas = "âŒ No conectado a Atlas"
    message_local = "âŒ No conectado a la BD local"

    try:
        # --- OperaciÃ³n en MongoDB Atlas ---
        if db_atlas is not None:
            log_doc = {
                "message": "OperaciÃ³n Flask en MongoDB Atlas (DatosSensores)",
                "timestamp": datetime.now().isoformat()
            }
            db_atlas["Log_Operaciones"].insert_one(log_doc)
            message_atlas = f"âœ… Documento insertado en {db_atlas.name}.ColecciÃ³n: Log_Operaciones"

        # --- OperaciÃ³n en MongoDB Local (si estÃ¡ conectada) ---
        if db_local is not None:
            db_local.local_data.update_one(
                {"_id": "contador"},
                {"$inc": {"count": 1}, "$set": {"last_update": datetime.now().isoformat()}},
                upsert=True
            )
            data = db_local.local_data.find_one({"_id": "contador"})
            count = data.get("count", 0)
            message_local = f"âœ… Contador local actualizado correctamente: {count}"

        return jsonify({
            "status": "success",
            "atlas_operation": message_atlas,
            "local_operation": message_local
        }), 200

    except Exception as e:
        print(f"âŒ Error en /vamos: {e}")
        return jsonify({
            "status": "error",
            "message": f"Error interno: {e}"
        }), 500


@app.route('/index')
def template_index():
    return render_template('index.html')


@app.route('/TestInsert')
def test_insert():
    """Inserta datos de prueba en las colecciones de sensores."""
    try:
        if db_atlas is None:

            return jsonify({"status": "error", "mensaje": "No hay conexiÃ³n a Atlas"}), 500

        sensores = [
            {"codigosensor": 1, "estado": 1, "TipoEjecucion": datetime.now()},
            {"codigosensor": 2, "estado": 0, "TipoEjecucion": datetime.now()},
            {"codigosensor": 3, "estado": 1, "TipoEjecucion": datetime.now()},
        ]

        colecciones_insert = {
            1: db_atlas.Sensor_1,
            2: db_atlas.Sensor_2,
            3: db_atlas.Sensor_3
        }

        insertados = []

        for sensor in sensores:
            resultado = colecciones_insert[sensor["codigosensor"]].insert_one(sensor)

            insertados.append({
                "coleccion": colecciones_insert[sensor["codigosensor"]].name,
                "insertado_id": resultado.inserted_id,
                "documento": sensor
            })

        respuesta = {
            "status": "ok",
            "mensaje": "Documentos insertados correctamente en Atlas",
            "detalles": insertados
        }

        return Response(
            json.dumps(respuesta, cls=JSONEncoder),
            mimetype="application/json",
            status=201
        )

    except Exception as e:
        print(f"âŒ Error al insertar: {e}")
        return Response(
            json.dumps({"status": "error", "mensaje": str(e)}, cls=JSONEncoder),
            mimetype="application/json",
            status=500
        )

def serialize_mongo_doc(doc):
    """
    Convierte ObjectId y datetime a tipos serializables por JSON.
    """
    safe_doc = {}
    for k, v in doc.items():
        if isinstance(v, ObjectId):
            safe_doc[k] = str(v)
        elif isinstance(v, datetime):
            safe_doc[k] = v.isoformat()
        else:
            safe_doc[k] = v
    return safe_doc


@app.route('/receive_sensor_data', methods=['POST'])
def receive_sensor_data():
    """Ruta para recibir datos JSON desde un ESP32 o dispositivo IoT."""
    try:
        if db_atlas is None:

            return jsonify({"status": "error", "mensaje": "No hay conexiÃ³n a Atlas"}), 500

        data = request.get_json()

        if not data or "codigosensor" not in data:
            return jsonify({"status": "error", "mensaje": "Falta el campo 'codigosensor'"}), 400

        codigosensor = int(data["codigosensor"])

        # Usamos el mapa COLECCIONES_MAP ya que contiene las referencias correctas
        if codigosensor == 1:
            collection = COLECCIONES_MAP.get("Sensor_1")
        elif codigosensor == 2:
            collection = COLECCIONES_MAP.get("Sensor_2")
        elif codigosensor == 3:
            collection = COLECCIONES_MAP.get("Sensor_3")
        else:
            return jsonify({"status": "error", "mensaje": "CÃ³digo de sensor no vÃ¡lido"}), 400

        print(f"ðŸ“¡ Recibido desde ESP32: {data}")

        # Crear documento a insertar
        doc_to_insert = {
            "codigosensor": codigosensor,
            "sensor_type": data.get("sensor_type", "Desconocido"),
            "valor": data.get("value"),
            "unidad": data.get("unit", "N/A"),
            "timestamp": datetime.now()
        }

        # Insertar en MongoDB
        resultado = collection.insert_one(doc_to_insert)

        # AÃ±adir el ID al documento para devolverlo
        doc_to_insert["_id"] = resultado.inserted_id

        # Serializar campos no compatibles (ObjectId, datetime)
        safe_doc = serialize_mongo_doc(doc_to_insert)

        print(f"âœ… Insertado en {collection.name} con ID {safe_doc['_id']}")

        return jsonify({
            "status": "ok",
            "mensaje": "Dato insertado correctamente",
            "coleccion": collection.name,
            "documento": safe_doc
        }), 201

    except Exception as e:
        print(f"âŒ Error al procesar datos: {e}")
        return jsonify({
            "status": "error",
            "mensaje": str(e)
        }), 500


@app.route('/tabla')
def tabla():
    """Muestra una tabla (asumiendo que db_atlas.p1 existe)."""
    # Nota: AsegÃºrate de que db_atlas.p1 exista
    if db_atlas is None:
         return "Error: No conectado a Atlas para la ruta /tabla", 503
    usuarios = list(db_atlas.p1.find({}, {"_id": 0}))
    return render_template('tabla.html', usuarios=usuarios)


# --------------------------------------------------------
#              RUTAS GRAFANA JSON DATA SOURCE
# --------------------------------------------------------

# 1. Health Check (Ruta de prueba de conexiÃ³n)
@app.route('/', methods=['GET'])
def grafana_health_check():
    """Ruta de verificaciÃ³n de salud de Grafana."""
    # Verificamos si al menos la conexiÃ³n a Atlas fue exitosa
    if client_atlas is not None:
        return "OK", 200
    else:
        return "Database Connection Error", 503

# 2. Search (Descubrimiento de mÃ©tricas)
@app.route('/search', methods=['POST'])
def search():
    """Devuelve la lista de mÃ©tricas disponibles para la consulta."""
    # Devuelve las claves del mapa (los nombres de los sensores)
    return jsonify(list(COLECCIONES_MAP.keys()))
# 3. Query (Consulta de datos)
@app.route('/query', methods=['POST'])
def query():
    try:
        req = request.get_json(silent=True) or {}
        target = req.get("target", "*")

        colecciones = {
            "Sensor_1": db_atlas.Sensor_1,
            "Sensor_2": db_atlas.Sensor_2,
            "Sensor_3": db_atlas.Sensor_3
        }

        respuesta = []

        for nombre, col in colecciones.items():

            # Si Grafana pide un target especÃ­fico
            if target != "*" and target != nombre:
                continue

            docs = list(col.find({}, {"_id": 0}))

            datapoints = []
            for d in docs:
                
                # ------------------------------
                # 1. Valor numÃ©rico
                # ------------------------------
                valor = d.get("Valor")
                if valor is None:
                    valor = 0
                else:
                    valor = float(valor)

                # ------------------------------
                # 2. Fecha -> timestamp UNIX ms
                # ------------------------------
                fecha = d.get("Fecha")

                if fecha is None:
                    ts = int(time.time() * 1000)
                else:
                    # Si es string
                    if isinstance(fecha, str):
                        try:
                            dt = datetime.fromisoformat(fecha)
                        except:  # noqa: E722
                            dt = datetime.utcnow()
                    else:
                        dt = fecha

                    ts = int(dt.timestamp() * 1000)

                datapoints.append([valor, ts])

            respuesta.append({
                "target": nombre,
                "datapoints": datapoints
            })

        return jsonify(respuesta)

    except Exception as e:
        return jsonify({"error": str(e)}), 500



if __name__ == '__main__':
    # Usar host='0.0.0.0' para que sea accesible externamente (como por Docker/Grafana)
    app.run(host='0.0.0.0', port=6001, debug=True)